---
tags:
- Go

title: "Go 中命名规范"
date: 2022-06-27T21:20:52+08:00
draft: false
---

> 计算机科学只存在两个难题：缓存失效和命名。—— Phil KarIton
>

Go，大道至简。其文件间可见性完全依赖于包，包绑定文件夹，因此项目基本上可以看作是用文件夹（包）来进行组织管理；其可见性管理依赖于首字母是否大写。此间种种，可谓大道至简，名副其实。

因此项目组织的良性就和标识符命名十分相关（强行相关

本文谨为笔者想法，仅供参考。

# 包名

包名大致上应当和目录名保持一致性。那么首先来了解一下目录名：

## 目录名

目录名大致反映了当前目录在项目组织中的地位。格式上为**小写**，长度上**短**，但是需要恰当**表达其含义**。

例如在标准库中有命名：/src/bufio，/src/crypto，/src/io，/src/math 等。需要注意是在 Go 中，import 时，格式为：

```go
import <package_name> "<package_path>"
```

其中 `<package_name>` 为该包在当前文件中的 local name，可以理解为得到一个 `<package_path>`下的包的引用名（Go 中实际上也是通过这种方式来避免在同一个文件中依赖相同名称的包），包名可以省略，则为默认包路径下使用的包名。

同一个目录下的所有文件包名相同，互相可见，仿佛在同一个文件中。因此可以将 Go 语言中的一个目录（包）看作 C++ 或其他语言中的一个文件。

其实要求 长度短 + 含义准确 其实是一个两难的权衡。一般而言使用一个**单词**即可，但是也有很多时候需要多个单词，例如很多目录名都会在前面标注上 go，多个单词命名用短横线来分开，如 `go-funk`，`go-toml` 等。

注意到目录名下还有一个文件名，上文中也提到，文件的地位在 Go 中地位被 包 替代，实际上没啥存在感，基本上可以使用一个单词，也没有必要考虑太多（因为没啥用，只是作为对包中代码的一个整理。需要多个单词可以用下划线分开。

## 包名

对于包名要求基本和目录名一致，基本上直接使用目录名即可，需要注意**和标准库中的包名区分开**，标准库使用更加频繁，如果同时出现就需要使用别名了（原则是尽可能少的使用别名）。但是这点比较难的是标准库中使用了很多需要用到的，例如 log，那么需要想办法换名字，例如有：logger，logging，总之需要换个名字。通过加个前缀的方式可能更加简单，但是就两个单词了，可能最终的妥协是使用一个下划线了（😭，例如 mo_log。

与目录名不同的情况：

- 目录中有短横线，包名中不能用短横线，可以考虑只用更短的部分，或者是用下划线（💩
- 最后一级目录表示版本号，如：github.com/gofiber/fiber/v2，那么这里的包名实际上还是 fiber（因为不同版本不会同时使用（大概

用**单数**。

# 变量&函数

**驼峰**，按照可见性确定首字母是否需要大写。

注意：

- 方法接收器（receiver），类似于其他语言中的 this 或者是 self，由于其在内部经常用到，且外部不可见，因此保持简短很重要（局部性比较强），可以使用类型的第一个字母或者表示含义的缩写；
- 变量中不需要含有类型的信息；

对于常量，和变量命名类似（也可以采用其他语言中使用全大写的方式，和变量以作区分，但是标准库中的均采用大驼峰

函数则是一个动词（动词短语），根据可见性确定首字母大小写。注意到包中的函数往往会和包名结合使用，例如：`fiber.New()`，那么这里的 `New()` 其实是借助了包名来完善其含义；例如标准库中的 `Once.Do()`也是类似的用法，即 包名+短动词。

方法与函数类似，表达的含义为“某对象做xxx“，因此其含义中自带了对象，需要表达清楚该对象做的事情即可。例如 结构体 `xxxList`，中方法 `Add` 。

结构体中属性一般为对外不可见，如果外部可读可写，那么大可以直接首字母大写 public，如果外部只读，可以安排一个同名首字母大写的 Get 方法，例如：

```go
package model
struct Person {
	  age int
    // ...
}

func NewPerson(xxx) Person {
    // Construct Person struct.
}

func (p *Person) Age() int {
    return p.age
}

// ...
func caller() {
    p := model.NewPerson(xxx)
    age := p.Age()
}
```

如果是特殊的 set 方法，例如通过输入几个基本类型，确定一个 struct 属性，那么可以写一个 `SetXxx()`方法。

注意，类似需要 JSON 序列化的 struct 中每个属性均需要首字母大写（对外可见）。

# 结构体&接口

结构体含义大致类似于类型，在面向对象语言中的类。驼峰，根据可见性首字母是否大写，一般为包外可见，即首字母大写，名词 or 动名词，表达该类型的含义。

接口表达为一类结构（类），格式和大小写方面与结构体名类似，往往以 “er“ 结尾，但是也不是绝对的，如果表达面向对象概念中抽象类类似的概念，那么就用抽象类名（与结构体名类似）了。

对于一些工具性的接口，不方便命名有一些技巧：

- 对于只有一个函数的接口，可以直接用函数名 + er，例如标准库中的 `Reader`（大概）
- 对于有两个函数的接口，那么可以两个函数名组合 + er（233，例如：

    ```go
    type WriteFlusher interface {
        Write([]byte) (int, error)
        Flush() error
    } 
    ```

- 三个及以上个数的函数就不建议直接用函数名了，大概可以抽象出一定的含义。

# Error 相关

自定义 Error 类型命名为 FooError 形式：

```go
type ExitError struct {
    // ....
}
```

Error 变量写成 ErrFoo 形式。

```go
var ErrFormat = errors.New("unknown format")
```

一般只需要使用 Error 变量即可，除非需要这个 Error 还有一些特殊的行为或者存储一些特殊的值才需要新构造一个结构体。

# 总结

基本上命名规范大致是有一个原则的，即调用处和声明处的距离，该距离越远，那么标识符需要越长，包含越多的信息。在命名时需要考虑该名称在何时何处，在何种语境下出现；命名优化的最好结果是消灭代码中所有的注释（受 Clean Code 毒害者